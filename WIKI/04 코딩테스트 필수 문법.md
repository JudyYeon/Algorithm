## 프리미티브 타입과 레퍼런스 타입
자바에는 int, long, float, double과 같은 프리미티브 타입primitive type과 Integer, Long, Float, Double과 같은 레퍼런스 타입reference type이 있습니다. 

- 결론부터 말하자면 이름에서도 알 수 있듯이 레퍼런스 타입은 참조형 변수이므로 프리미티브 타입보다 연산 속도가 더 느림
- 특별한 경우가 아니라면 대부분 프리미티브 타입으로 설명함
- 하지만 레퍼런스 타입은 컬렉션 프레임워크 등에서 정수형 또는 부동소수형을 저장할 때 사용하기 때문에 반드시 알고 넘어가야함

### 정수형

정수형은 양과 음의 정수, 0을 포함합니다. 정수형은 더하기, 빼기, 곱하기, 나누기와 같은 사칙 연산 외 많은 연산을 할 수 있습니다. 

대표적인 예로 지수 연산을 하는 ** 연산자와 정수 나눗셈 연산의 몫만 반환하는 // 연산자가 있습니다. 


### 정수형 변수 선언

``` java
int a = 13
int b = 4
```

### 정수형 산술 연산
```java
System.out.println(a + b);    // 더하기 / 17
System.out.println(a - b);    // 빼기 / 9
System.out.println(a * b);    // 곱하기 / 52
System.out.println(a / b);    // 나누기 (소수점 버림) / 3
System.out.println(a % b);    // 모듈러 연산 (소수점 버림) / 1
```


### 정수형 비교 연산
```java
System.out.println(a == b)  # 같은 값인지 비교 / false
System.out.println(a != b)  # 같지 않은 값인지 비교 / true
System.out.println(a > b)   # 왼쪽 값이 더 큰지 비교 / true
System.out.println(a < b)   # 왼쪽 값이 더 작은지 비교 / false
System.out.println(a >= b)  # 왼쪽 값이 더 크거나 같은지 비교 / true
System.out.println(a <= b)  # 왼쪽 값이 더 작거나 같은지 비교 / false
```

### 정수형 비트 연산
```java
System.out.println(a & b)   # AND   / 4
System.out.println(a | b)   # OR    / 13
System.out.println(a ^ b)   # XOR   / 9
System.out.println(~a)      # NOT   / -14
System.out.println(a << 2)  # 왼쪽 시프트 (a에 2^2를 곱한 것과 동일)  / 52
System.out.println(a >> 1)  # 오른쪽 시프트 (a를 2^1로 나눈 것과 동일) / 6 
```

### 부동소수형

부동소수형은 소수를 저장할 때 사용합니다. 부동소수형도 연산 결과를 보며 설명하겠습니다.

### 부동소수형 사칙 연산과 모듈러 연산
```java
System.out.println(2.5 + 3.7)   # 더하기   / 6.2
System.out.println(7.9 - 4.2)   # 빼기    / 3.7
System.out.println(1.5 * 4.8)   # 곱하기   / 7.199999999999999
System.out.println(10.0 / 3.2)  # 나누기   / 3.125 
System.out.println(10.0 % 3.2)  # 모듈러   / 0.39999999999999947
```

### 부동소수형 논리 연산
```java
double x = 0.5;
double y = 1.2;
double z = 2.0;
System.out.println(x > y && y < z); // AND 연산 / false
System.out.println(x < y || y < z); // OR 연산 / true
System.out.println(!(x > y));       // NOT 연산 / true
```

부동소수형 코드 실행 결과를 보면 눈에 띄는 내용이 있습니다. 
10 % 3.2의 연산 결과를 보면 결괏값이 0.4가 아니라 0.39999999999999947입니다.

### 엡실론을 포함한 연산에 주의하라

이런 이유는 자바는 부동소수형 데이터를 이진법으로 표현하기 때문입니다. 
표현 과정에서 오차가 발생하는 것이죠. 이를 엡실론epsilon이라고 합니다. 

구체적인 내용은 문법서에서 공부하는 것이 더 적합하므로 여기서는 생략하겠습니다. 

제가 이 내용을 언급한 이유는 코딩 테스트에서 부동소수형 데이터를 다룰 일이 생겼을 때 이 엡실론을 항상 생각하라는 이유에서입니다. 


여러분이 부동소수형을 사용하여 코드를 작성하면 엡실론이라는 요소 때문에 일부 테스트 케이스가 통과하지 못할 수도 있으니 유의하기 바랍니다.

마찬가지의 이유로 0.1을 3번 더한 a의 값에 0.3을 빼면 0이 아닙니다.

```java
public class Solution {
  public static void main(String[] args) {
    double epsilon = 1E-5;

    // 앱실론 출력
    System.out.println(epsilon); // 1.0E-5

    // 부동소수점 수 오차 검사
    double a = 0.1 + 0.2;
    double b = 0.3;
    System.out.println(a - b); // 5.551115123125783E-17

    if (a == b) {
      System.out.println("a와 b는 같은 값입니다.");
    } else {
      System.out.println("a와 b는 다른 값입니다."); // 이 코드가 출력됨
    }

    if (Math.abs(a - b) < epsilon) {
      System.out.println("a와 b는 같은 값입니다."); // 이 코드가 출력됨
    } else {
      System.out.println("a와 b는 다른 값입니다.");
    }
  }

}
```

부동소수형 데이터를 활용하는 문제는 오차 허용 범위를 언급하는 경우가 많습니다. 문제를 분석할 때 꼭 이 부분을 체크하기 바랍니다. 

이 지점에서 정말 많은 사람이 실수합니다.

다음은 컬렉션 프레임워크에서 래퍼런스 타입 사용에 대한 예입니다. 

다음 장에서 다룰 컬렉션 프레임워크에서 사용해야 되기 때문에 꼭 기억하고 넘어가주세요. 


long을 선언할 때 프리미티브 타입이 필요한 상황에서는 꼭 소문자 l로 시작하는 long을 사용해주세요. 실수하기 쉬운 부분입니다.

```java
// 프리미티브 타입 사용법
int i = 0;
long[] longs = new long[10];
float f = 10.5f;
double d = 10 / 3.0;

// 레퍼런스 타입 사용법(꼭 필요한 경우가 아니면 권장하지 않음)
Integer I = 0;
Long[] Longs = new Long[10];
Float F = 10.5f;
Double D = 10 / 3.0;

// 문법 오류 발생
ArrayList<int> arrayList = new ArrayList<>();
Stack<long> stack = new Stack<>();
Queue<float> queue = new Queue<>();
ArrayDeque<double> arrayDeque = new ArrayDeque<>();

// 올바른 코드
ArrayList<Integer> arrayList = new ArrayList<>();
Stack<Long> stack = new Stack<>();
Queue<Float> queue = new ArrayDeque<>();
ArrayDeque<Double> arrayDeque = new ArrayDeque<>();
```
